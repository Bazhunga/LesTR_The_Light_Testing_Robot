#include <p18f4620.inc>

    #include <rtc_macros.inc>
    list P=18F4620, F=INHX32, C=160, N=80, ST=OFF, MM=OFF, R=DEC
    errorlevel -302
    errorlevel -305
;;;;;;Configuration Bits;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

		CONFIG OSC=INTIO67, FCMEN=OFF, IESO=OFF
		CONFIG PWRT = OFF, BOREN = SBORDIS, BORV = 3
		CONFIG WDT = OFF, WDTPS = 32768
		CONFIG MCLRE = ON, LPT1OSC = OFF, PBADEN = OFF, CCP2MX = PORTC
		CONFIG STVREN = ON, LVP = OFF, XINST = OFF
		CONFIG DEBUG = OFF
		CONFIG CP0 = OFF, CP1 = OFF, CP2 = OFF, CP3 = OFF
		CONFIG CPB = OFF, CPD = OFF
		CONFIG WRT0 = OFF, WRT1 = OFF, WRT2 = OFF, WRT3 = OFF
		CONFIG WRTB = OFF, WRTC = OFF, WRTD = OFF
		CONFIG EBTR0 = OFF, EBTR1 = OFF, EBTR2 = OFF, EBTR3 = OFF
		CONFIG EBTRB = OFF
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;MACROS;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

i2c_common_check_ack macro err_address ;If bad ACK bit received, goto err_address
    btfsc SSPCON2,ACKSTAT
    goto err_address
    endm

i2c_common_start macro
;input: none
;output: none
;desc: initiate start conditionon the bus
    bsf SSPCON2,SEN
    btfss PIR1, SSPIF
    bra $-2

    bcf PIR1, SSPIF ;clear SSPIF interrupt bit

    endm

i2c_common_stop macro
;input: none
;output: none
;desc: initiate stop condition on the bus
    bsf SSPCON2,PEN
    btfsc SSPCON2,PEN
    bra $-2
    bcf PIR1, SSPIF
    endm

i2c_common_repeatedstart macro
;input: none
;output: none
;desc: initiate repeated start on the bus. Usually used for
; changing direction of SDA without STOP event
    bsf SSPCON2,RSEN
    btfss PIR1, SSPIF
    bra $-2

    bcf PIR1, SSPIF ;clear SSPIF interrupt bit

    endm

i2c_common_ack macro
;input: none
;output: none
;desc: send an acknowledge to slave device
    bcf SSPCON2,ACKDT
    bsf SSPCON2,ACKEN
    btfsc SSPCON2,ACKEN
    bra $-2
    endm

i2c_common_nack macro
;input: none
;output: none
;desc: send an not acknowledge to slave device

    bsf SSPCON2,ACKDT
    bsf SSPCON2,ACKEN

    _waitl#v(_waitknt)
    btfsc SSPCON2,ACKEN
    goto _waitl#v(_waitknt)
    _waitknt set _waitknt+1
    endm

i2c_common_write macro

;input: W
;output: to slave device
;desc: writes W to SSPBUF and send to slave device. Make sure
; transmit is finished before continuing

    btfsc SSPSTAT, BF
    bra $-2

    movwf SSPBUF

    btfss PIR1, SSPIF
    bra $-2
    bcf PIR1, SSPIF ;clear SSPIF interrupt bit

    endm

i2c_common_read macro
;input: none
;output: W
;desc: reads data from slave and saves it in W.

    bsf SSPCON2,RCEN ;Begin receiving byte from
    btfss PIR1, SSPIF
    bra $-2
    bcf PIR1, SSPIF
    movf SSPBUF,w
    endm

TABLEREAD macro name
    local repeat
    movlw   upper name
    movwf   TBLPTRU
    movlw   high name
    movwf   TBLPTRH
    movlw   low name
    movwf   TBLPTRL
    tblrd*
    movf    TABLAT, W    ;Display welcome message using stuff from tables

repeat
    call    WrtLCD
    tblrd+*
    movf    TABLAT, W
    bnz repeat

    endm

WRT_LCD macro val
    movlw   val
    call    WrtLCD
    endm

;Delay: ~44us
LCD_DELAY macro
    movlw   0x23
    movwf   lcd_d1
    decfsz  lcd_d1,f
    goto    $-2
    endm

INST_MODE_LCD macro
    bcf     PORTD, RS  ;In instruction mode, LCD gets sent instructions to manipulate text
    endm

DISP_MODE_LCD macro
    bsf     PORTD, RS
    endm
GETINPUT macro MenuScreen
    local HoldingTimeCheck
    local HoldingTimeChecks
    local endMacro
    btfss	PORTB,1   ;Wait until data is available from the keypad
    goto    $-2
    ;Pressed D --> Hold to check time
    ;Special Case

    swapf   PORTB,W     ;Read PortB<7:4> into W<3:0>
    andlw	0x0F
    movwf   keyPressed

    movlw   b'00001111'
    subwf   keyPressed, W
    bz      HoldingTimeCheck

    btfsc	PORTB,1
    goto    $-2
    goto    endMacro
;    swapf   PORTB,W     ;Read PortB<7:4> into W<3:0>
;    andlw	0x0F
HoldingTimeCheck
    call	ClrLCD
HoldingTimeChecks
    btfss   PORTB, 1
    goto    MenuScreen
    call    show_RTC
    goto    HoldingTimeChecks

endMacro
    endm

ROTATEDELAY macro
    call rotTimeDelay
    endm

DELAY macro
    call halfSecondDelay
    ;call halfSecondDelay
    ;call halfSecondDelay
    endm
OPDELAY macro
    call OperationDelay
    endm

OPDELAY2 macro
    call OperationDelay
    call OperationDelay
    endm

PCDelay macro
    call S_WAIT
    call S_WAIT
    call S_WAIT
    call S_WAIT
    call S_WAIT
    endm

DISPLAYTIMEFROMROM macro
    call UpdateLCDwEEP
    call UpdateLCDwEEP

    movlw	":"
    call	WrtLCD

    call UpdateLCDwEEP
    call UpdateLCDwEEP

    movlw	":"
    call	WrtLCD

    call UpdateLCDwEEP
    call UpdateLCDwEEP
    endm

;;;Vectors;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;global labels

    variable _waitknt=0

    udata
lcd_temp            res 1
lcd_d1              res 1
lcd_d2              res 1
halfsecA            res 1
halfsecB            res 1
halfsecC            res 1
keypadInput         res 1
keyPressed          res 1
regaddress          res 1
databyte            res 1
datachar            res 1
tens_digit          res 1 ;Tens digit of RTC Output
ones_digit          res 1 ;Ones digit of RTC Output
convert_buffer      res 1 ;Used for RTC
lightCount          res 1 ;present number of lights
nolightCount        res 1 ;absent number of lights
lightStatus         res 1 ;1 means working, 0 means nope
lightTotal          res 1 ;sum of nolightcount and lightcount
brokenLightCount    res 1 ;Used in the faulty, good light display to help with branching and EEADR decrementing
lightLabel          res 1 ;label the lights as 1,2,3,4,5,6,7 etc
dispLightCount      res 1 ;Used when looping through EEPROM to output broken LEDs
dutyCycle           res 1
servoTestPosition   res 1
adconZeroConfig     res 1
tempLight23avg      res 1   ;Stores a snapshot of the photoresistor reading average before light shines on light 2 and 3 (taken when checking light 1)
tempLight4          res 1   ;Reading light comes on it
tempLight5          res 1
tempLight6          res 1
tempLight7          res 1
lightThreshold      res 1
EEPCounter          res 1  ;Counter for EEPROM address
possibleAA          res 1
dutyCycleLSB        res 1

;For time subtraction/timing
timingTenMin        res 1
timingMinute        res 1
timingTenSec        res 1
timingOneSec        res 1
timingTenMinE       res 1
timingMinuteE       res 1
timingTenSecE       res 1
timingOneSecE       res 1
timingTotal         res 1

;For PC Interfacing
passedLights        res 1
failedLights        res 1
badHeadLightFlag    res 1

opstartht           res 1
opstartho           res 1

;Binary to Ascii variables
ones                res 1
huns                res 1
tens                res 1
count               res 1
BIN                 res 1

TIMCNT	EQU	020H
LPCNT	EQU	021H
TDATA	EQU	022H


RS      equ 2
E       equ 3


;;;Begin;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    org     0x0000
    goto    Init
    org     0x08
    retfie          ; high priority ISR
    org     0x18    ; low priority ISR
    retfie          ;Return

    code
;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;***********Main Code******************************************************
;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

;;;TABLES-16 Letter Capacity;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;40 letters until wrap to next line
;"""11111111111111111111111111111111111111112222222222222222222222222222222222222222" This is a template to partition top and bottom rows easily
WelcomeScreen
    db "Welcome to LesTR                        Press any key", 0
MenuScreen1
    db "1.Start Checking" , 0
MenuScreen2
    db "2.System Options", 0
MenuScreen3
    db "3.Prev Results", 0
MenuScreen4
    db "4.System Time", 0
OpStart1
    db "Inspecting.", 0
OpStart2
    db "Inspecting..", 0
OpStart3
    db "Inspecting...", 0
SystOpt1
    db "1.Tray Test", 0
SystOpt2
    db "2.Test Solenoid",0
AIM1
    db "1.Bad Light List", 0
AIM2
    db "2.Light total", 0
AIM3
    db "3.Operation Time", 0
AIM4
    db "4.Export/Restart", 0
GoodList
    db "O:", 0
BadList
    db "X:", 0
BadLEDList
    db "List of Bad LEDS", 0
NumLights
    db "# of lights: ", 0
TimeOperation
    db "0<x<90 seconds", 0
StartAnew
    db "Remove Tray", 0
PressAnyKey
    db "Press Any Key", 0
StartLabel
    db "Start: ", 0
EndLabel
    db "End  : ", 0
LineOfBlanks
    db "                ", 0
DoesNotExist
    db "DNE", 0
OtherExport
    db "1.Export data", 0
OtherNewTest
    db "2.New Test", 0
OperationTime
    db "Operation Time", 0
Seconds
    db " seconds ", 0
Prev1
    db "1- ", 0
Prev2
    db "2- ", 0
Prev3
    db "3- ", 0
Prev4
    db "4- ", 0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Init
    clrf    INTCON


    ;;;;;;;;;;;;;INITIALIZE OSCILLATOR STUFF from sample code;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;    movlw	B'01110000'	;set internal oscillator frequency
;    movwf	OSCCON		;to 8 MHz
;    bsf		OSCTUNE, 6	;turn on PLL to enable 32MHz clock frequency
;    bra		INIT

    bcf		INTCON,GIE	;disable global interrupt
    bcf		INTCON,PEIE
;    movlw	B'00001110'	;configure ADCON1
;    movwf	ADCON1
;    movlw	B'00100110'	;configure ADCON2
;    movwf	ADCON2
;    clrf   	TRISB		;configure PORTB as output
;    bra		ADSTART



    movlw   b'00111111'     ;activate required bits 5- 0 for sensor inputs
    movwf   TRISA
;   clrf    TRISA
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;movlw   b'00001111' Turn everything to digital
    movlw   b'00001001' ;RE1, RA5, RA3, RA2, RA1 and RA0 are now analog inputs. RB3 for middle light is still digital (Pending changes)
    movwf   ADCON1
    movlw	B'00100110'	;configure ADCON2
    movwf	ADCON2
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    

    movlw   b'11111110'     ;activate required bits 7,6,5,4 for keypad inputs and 3 for middle light sensor input and 2 for the microswitch input and 1 for keypad input
    movwf   TRISB
    clrf    TRISD         ; All port D is output

    movlw	B'11000000'
	movwf	TRISC	;set RC7=USART RC, RC6=USART TX
    clrf    TRISE

    
    ;Set SDA and SCL to high-Z first as required for I2C
    bsf	   TRISC,4
    bsf	   TRISC,3

    clrf      LATA          ;Clear data in each latch
    clrf      LATB
    clrf      LATC
    clrf      LATD


   
    ;Set up I2C for communication
    call   i2c_common_setup
    ;rtc_resetAll
    ;Set up PC Interfacing
    call   InitPCInterface

    call   InitLCD ;Initialize the LCD Code
    ;call ClearEEPROM
    call   InitEEPROM

;    ;CLEAR EEPROM SUBROUTINE
;    clrf    EEADR ;Put eeadr to the beginning
;    clrf    WREG
;    movwf   EEPCounter
;    ;call    TestPC
;ClearAllEEP
;    call    ResetEEPROM
;    incf    EEPCounter
;    movlw   b'01001100' ;Total number of entries in eeprom after light checking is 76.
;    ;One is subtracted each time and that address is cleared
;    subwf   EEPCounter, W
;    bnz     ClearAllEEP
;    clrf    EEADR

    ;Reset Tray Position
;    movlw   b'00000011'
;    movwf   dutyCycle
;    call    pulseTesters
;    DELAY
;    movlw	B'00000000'	;configure CCP2CON, turn PWM off
;    movwf	CCP2CON


;***************************************
; Setup RTC with time defined by user
;***************************************
;        set_rtc_time
;
;		rtc_resetAll	;reset rtc
;
;		rtc_set	0x00,	B'10000000'
;
;		;set time
;		rtc_set	0x06,	B'00010100'		; Year
;		rtc_set	0x05,	B'00000100'		; Month
;		rtc_set	0x04,	B'00000101'		; Date
;		rtc_set	0x03,	B'00000110'		; Day
;		rtc_set	0x02,	B'00010010'		; Hours
;		rtc_set	0x01,	B'01010111'		; Minutes
;		rtc_set	0x00,	B'00000000'		; Seconds
;		return
;Dummy Code
        

;==============================================================================================================
;Stage 1. Welcome Screen. Display a welcome message
;Advancing to next stage requires pressing a button
;==============================================================================================================
Welcome
        
        TABLEREAD WelcomeScreen
        

StartingScreen


        ;call    SftLft
        btfss	PORTB,1   ;Wait until data is available from the keypad
        goto    StartingScreen
        btfsc	PORTB,1
        goto    $-2
        

;==============================================================================================================
;Stage 2. Menu Screen. Display the options that the user can select
;Advancing to next stage requires pressing a button corresponding with a coice
;==============================================================================================================
MenuScnSA ;-Menu Screen Start A
        call    ClrLCD
                TABLEREAD MenuScreen1
        call    Switch_Lines
                TABLEREAD MenuScreen2

;>>Polling For Entry. If 1, go to start op, if 2, go to options, if 3, go to etc etc
MssaWait
        call resetTray
;        DELAY
;        movlw	B'00000000'	;configure CCP2CON, turn it into PWM mode (1100)
;		movwf	CCP2CON


        GETINPUT MenuScnSA
        ;movwf   keyPressed
;Pressed # --> Next Page
        movlw   b'00001110'
        subwf   keyPressed, W     ;User entered 1, proceed with 1
        bz      GoToMSSB
;Pressed * --> Prev Page
        movlw   b'00001100'
        subwf   keyPressed, W
        bz      GoToMSSB

;Pressed 1 --> Start
        movlw   b'00000000'
        subwf   keyPressed, W
        bz      OperationStart
;Pressed 2 --> System Options
        movlw   b'00000001'
        subwf   keyPressed, W
        bz      GoToSO
        goto    MssaWait

;Branch hub
GoToMSSB
        goto     MenuScnSB
GoToSO
        call    ClrLCD
        goto    SystOpt
        

;==============================================================================================================
;Stage 2.1. Operation Start
;Users can abort the process using the key 0
;==============================================================================================================
;PSEUDOCODE:
;Will need to reset tray by rotating it until it hits the microswitch
    

;;Solenoid, Check Light, Rotate, repeat
OperationStart
    
    clrf    EEADR
    clrf    EEADRH
    decf    EEADR
    call    PutTimeIntoEEP ;Gets the time and stores it into EEPROM
    ;______________________ Used to get the starting minute, ten sec and one sec from the PutTimeIntoEEP subroutine
    movff   timingTenMinE, timingTenMin
    movff   timingMinuteE, timingMinute
    movff   timingTenSecE, timingTenSec
    movff   timingOneSecE, timingOneSec
    ;_______________________

    movlw   b'0'
    movwf   nolightCount ;Reset the variables
    movwf   lightCount
    movwf   lightLabel
    movwf   failedLights
    movwf   passedLights

    movlw   b'00001000'
    movwf   lightThreshold    

    ;Beginning, reset tray with duty cycle and duty cycle LSB
    movlw   b'00010000'
    movwf   dutyCycle
    movlw   b'00001100'
    movwf   dutyCycleLSB

    call    pulseTesters ;Change the rotation
    call    CheckLight
    

CycleOperation
    call    RotateTray ;Rotate halfway to the next light
    call    RotateTray ;Rotate tray finally to next light
    call    IsLightAvailable ;Check if we should check the light or not, increment appropriate light counter
    ;If the light is availalbe, checklight is carried out. Otherwise, Nolight is carried out
    call    IsProcessFinished
    goto    CycleOperation

RotateTray 
    decf    dutyCycle
    movff   dutyCycle,CCPR2L

    movlw   b'00111100' ;11
    movwf   dutyCycleLSB
    movff   dutyCycleLSB, CCP2CON

    ROTATEDELAY
    movlw   b'00010000'
    subwf   dutyCycleLSB, f ;10
    movff   dutyCycleLSB, CCP2CON
    ROTATEDELAY
    movlw   b'00010000'
    subwf   dutyCycleLSB, f ;01
    movff   dutyCycleLSB, CCP2CON
    ROTATEDELAY
    movlw   b'00010000'
    subwf   dutyCycleLSB, f ; 00
    movff   dutyCycleLSB, CCP2CON
    ROTATEDELAY
    ROTATEDELAY



;    DELAY
;    decf    dutyCycle
;    movff   dutyCycle, CCPR2L
;    DELAY
    return


IsLightAvailable
    btfss   PORTB, 2 ;If there is a light (indicated by microswitch), call checklight
    call    NoLight ;Otherwise, there is no light, so skip the logs accordingly
    btfsc   PORTB,2
    call    CheckLight
    return

NoLight
    incf    nolightCount
    incf    lightLabel
    incf    EEADR
    movff   lightLabel, EEDATA ;Puts the light number into EEPROM
    call    Write_EEPROM
    call    BlankLightLog ;Creates a blank entry of 7 LED Statuses
    return


CheckLight
    clrf    badHeadLightFlag
    incf    lightCount
    incf    lightLabel
    incf    EEADR
    movff   lightLabel, EEDATA ;Puts the light number into EEPROM
    call    Write_EEPROM
    movlw   b'00000000' ;Reset averages
    movwf   tempLight23avg
    ;movwf   tempLight4567avg

    ;Stage One ;Remains digital, for now.>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    call    ClrLCD
    TABLEREAD OpStart1 ;Inspecting.
    OPDELAY
    ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    call    SolenoidPulse ;Turn on one light
    call    resetLightStatus


    btfsc   PORTB, 3 ;Middle Light
    movlw   b'00000001'
    call    LEDStatToProm ;Moves the W register (0 or 1) into the LightStatus variable, which is then stored into EEPROM indicating good or bad light

    ;Getting pre-lit average on sensors 2 and 3
    ;____________________________________________________________________________________________
    movlw   b'00000001' ;Configure AD to read AN0
    movwf   adconZeroConfig
    call    AD_CONV
    addwf   tempLight23avg

    movlw   b'00010001' ;Configure AD to read AN4
    movwf   adconZeroConfig
    call    AD_CONV
    addwf   tempLight23avg

    rrncf   tempLight23avg  ;Shift bits to the right (no carry), thereby dividing by 2
    clrf    WREG
    addwf   tempLight23avg, W
    andlw   b'01111111'
    movwf   tempLight23avg
    ;andwf   tempLight23avg, f ;get rid of the first bit resulting from the rotation


    ;____________________________________________________________________________________________

    ;Stage Two (Checks two lights)>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>)
    ;Lights shall be considered "on" if the difference is larger than 0x10

    call    ClrLCD
    TABLEREAD OpStart2 ;Inspecting..
    OPDELAY

    ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    call    SolenoidPulse ;Turn on row of lights

    ;====ANALOG CONFIG.==================================================
    movlw   b'00000001' ;Configure AD to read AN0 (Bottom Light)
    movwf   adconZeroConfig ;Reset the ADCON
    call    AD_CONV ;Start Conversion

    subfwb  tempLight23avg, W ;subtract tempLight23avg from the obtained value and store back in W
    call    lightADAnalysis ;Checks if a 1 or 0 should be assigned to the LED

    ;====================================================================



    ;call    LEDStatToProm
    call    resetLightStatus
    ;====ANALOG CONFIG.==================================================
    movlw   b'00010001' ;Configure AD to read AN4
    movwf   adconZeroConfig
    call    AD_CONV

    subfwb  tempLight23avg, W ;subtract tempLight23avg from w and store back in W
    call    lightADAnalysis
    ;====================================================================

    ;call    LEDStatToProm
    call    resetLightStatus

    ;____________________________________________________________________________________________
    movlw   b'00001101' ;Configure AD to read AN3
    movwf   adconZeroConfig
    call    AD_CONV
;call    LEDStatToProm
    movwf   tempLight4

    movlw   b'00001001' ;Configure AD to read AN2
    movwf   adconZeroConfig
    call    AD_CONV
;call    LEDStatToProm
    movwf   tempLight5

    movlw   b'00000101' ;Configure AD to read AN1
    movwf   adconZeroConfig
    call    AD_CONV
;call    LEDStatToProm
    movwf   tempLight6

    movlw   b'00010101' ;Configure AD to read AN5
    movwf   adconZeroConfig
    call    AD_CONV
;call    LEDStatToProm
    movwf   tempLight7

    ;____________________________________________________________________________________________


    ;Stage Three==================================================================================>>>>>>
    call    ClrLCD
    TABLEREAD OpStart3 ;Inspecting...
    OPDELAY

    ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    call    SolenoidPulse ;Turn on all lights
    OPDELAY

    call    resetLightStatus
    ;====ANALOG CONFIG.==================================================
    movlw   b'00001101' ;Configure AD to read AN3
    movwf   adconZeroConfig
    call    AD_CONV
    ;call    LEDStatToProm

    subfwb  tempLight4, W ;subtract tempLight23avg from w and store back in W
    call    lightADAnalysis
    ;====================================================================
    call    resetLightStatus

    ;====ANALOG CONFIG.==================================================
    movlw   b'00001001' ;Configure AD to read AN2
    movwf   adconZeroConfig
    call    AD_CONV


    subfwb  tempLight5, W ;subtract tempLight23avg from w and store back in W
    call    lightADAnalysis

    ;====================================================================

    call    resetLightStatus

    ;====ANALOG CONFIG.==================================================
    movlw   b'00000101' ;Configure AD to read AN1
    movwf   adconZeroConfig
    call    AD_CONV


    subfwb  tempLight6, W ;subtract tempLight23avg from w and store back in W
    call    lightADAnalysis
    ;====================================================================

    call    resetLightStatus

    ;====ANALOG CONFIG.==================================================
    movlw   b'00010101' ;Configure AD to read AN5
    movwf   adconZeroConfig
    call    AD_CONV


    subfwb  tempLight7, W ;subtract tempLight23avg from w and store back in W
    call    lightADAnalysis
    ;====================================================================

    call    resetLightStatus
    call    SolenoidPulse ;Turn off all lights
    OPDELAY
    incf    EEADR
    
    ;Check if the entire light is good or not
    clrf    WREG
    addwf   badHeadLightFlag, W ;See if the flag is 0 or not zero. If 0, light is perfect

    decf    WREG    ;If WREG decreases by 1 and was previously 0, status bit Negative would be raised. Check that
    btfss   STATUS, 4 ;If WREG doesn't become negative, the value was > 0 and thus light is bad
    incf    failedLights
    return
    
IsProcessFinished ;Once absent + present = 7, finish
    movlw   b'00000000'
    addwf   lightCount, W ;Add number of lights to W

    addwf   nolightCount, W ;Add absence of lights to W
    movwf   lightTotal

    movlw   b'00000111'
    subwf   lightTotal, W
    bz      TerminateProcess ;Once 7 is reached, we move on
    return
;END ROTATE PROCESS

TerminateProcess
    incf    EEADR
    movff   lightCount, EEDATA
    call    Write_EEPROM
        ;We're done here

CalculateGoodLights
    clrf    WREG
    addwf   failedLights, W
    subwf   lightCount, W
    movwf   passedLights


TurnOffPWM
    movlw   b'00000000'
    movwf   CCP2CON
    movlw	B'01110000'	;Set internal oscillator frequency to 8MHz
	movwf	OSCCON ;Might not need to change this!
    goto    GetEndTime

GetEndTime
    call PutTimeIntoEEP ;Gets the time and stores it into EEPROM
    call CalcOpTime

    goto    AftInsMenuA
;==============================================================================================================
;Stage 2.2. System Options
;Users can go back using the * button
;==============================================================================================================
SystOpt
        call        ClrLCD
        TABLEREAD   SystOpt1
        call        Switch_Lines
        TABLEREAD   SystOpt2
        movlw       b'00000101'
        movwf       dutyCycle
SystOptWait
        GETINPUT    SystOpt
        ;movwf   keyPressed
;Pressed *
        movlw   b'00001100'
        subwf   keyPressed, W
        bz      goBack
;Pressed 1
        movlw   b'00000000'
        subwf   keyPressed, W
        bz      pulseTesterStart
;Pressed 2
        movlw   b'00000001'
        subwf   keyPressed, W
        bz      goToSolenoidPulse

        goto    SystOptWait

goBack
        goto    MenuScnSA
        ;goto    SystOpt
goToSolenoidPulse
        call    SolenoidPulse
        goto    SystOptWait

;;;;;;;;;;;;;;;Pulse Testing Page;;;;;;;;;;;;;;;;;;;
pulseTesterStart
        call    ClrLCD
        call    pulseTesters

pulseTesterMenuLoop
        ;Needs to be improved such that the appropriate number is placed into CCP2
        ;Then go back to the pulse testing again and reexecute
        GETINPUT    pulseTesterMenuLoop
        ;movwf   keyPressed
;Pressed *
        movlw   b'00001100'
        subwf   keyPressed, W
        bz      returnToSystOpt

;Pressed 1
        movlw   b'00000000'
        subwf   keyPressed, W
        bz      PulseWidthOne

;Pressed 2
        movlw   b'00000001'
        subwf   keyPressed, W
        bz      PulseWidthTwo

;Pressed 3
        movlw   b'00000010'
        subwf   keyPressed, W
        bz      PulseWidthThree
        goto    pulseTesterMenuLoop

returnToSystOpt
        movlw	B'00000000'	;configure CCP2CON, turn it into PWM mode (1100)
		movwf	CCP2CON
        goto    SystOpt

PulseWidthOne
        movlw   b'00000110' ;Starting servo position
        movwf   dutyCycle
        movlw   b'00001100'
        movwf   dutyCycleLSB
        goto    pulseTesterStart

PulseWidthTwo
        movlw   b'00000110' ;Starting servo position
        movwf   dutyCycle
        movlw   b'00011100'
        movwf   dutyCycleLSB
        goto    pulseTesterStart

PulseWidthThree
        movlw   b'00000110' ;Starting servo position
        movwf   dutyCycle
        movlw   b'00101100'
        movwf   dutyCycleLSB
        goto    pulseTesterStart


;==============================================================================================================
;Stage 2a. 2nd page of Menu Screen. Display the options that the user can select
;Users can go back to the first page using * or #
;==============================================================================================================
MenuScnSB ;Updates Display
        call    ClrLCD
        TABLEREAD MenuScreen3
        call Switch_Lines
        TABLEREAD MenuScreen4

MssbWait
        GETINPUT MenuScnSB

;Pressed #
        ;movwf   keyPressed
        movlw   b'00001110'
        subwf   keyPressed, W     ;User entered 1, proceed with 1
        bz      GoToMSSA
;Pressed *
        movlw   b'00001100'
        subwf   keyPressed, W
        bz      GoToMSSA
;Pressed 3
        movlw   b'00000010'
        subwf   keyPressed, W
        bz      goToPrevResults
;Pressed 4
        movlw   b'00000100'
        subwf   keyPressed, W
        bz      goToSystTime

        goto    MssbWait
GoToMSSA ;bz doesn't not have enough range to extend to menuscnsa
        goto    MenuScnSA
goToSystTime
        call	ClrLCD
        goto    SystemTime
goToPrevResults
        goto    PrevResults
;==============================================================================================================
;Stage 2.3. Prev Results
;Users can go back using the * button
;==============================================================================================================

PrevResults
    call    ClrLCD
    clrf    EEADR
    clrf    EEADRH
    incf    EEADRH
    call    goToEndOfProm

    

    TABLEREAD   Prev1
    call    OutputLog

    call Switch_Lines
    
    TABLEREAD   Prev2
    movlw   d'2'
    subwf   EEADR, F
    call    OutputLog
    
    btfss	PORTB,1   ;Wait until data is available from the keypad
    goto    $-2
    btfsc	PORTB,1
    goto    $-2
    call    ClrLCD
    
    TABLEREAD   Prev3
    movlw   d'2'
    subwf   EEADR, F
    call    OutputLog

    call Switch_Lines

    TABLEREAD   Prev4
    movlw   d'5'
    subwf   EEADR, F
    call    OutputLog


    btfss	PORTB,1   ;Wait until data is available from the keypad
    goto    $-2
    btfsc	PORTB,1
    goto    $-2
    call    ClrLCD

    goto    MenuScnSB
    
;==============================================================================================================
;Stage 2.4. System Time
;Users can go back using the * button
;==============================================================================================================
;PSEUDOCODE FOR TIME

SystemTime
        call    show_RTC

        btfss	PORTB,1   ;Wait until data is available from the keypad
        goto    SystemTime
        btfsc	PORTB,1
        goto    $-2
        swapf   PORTB,W     ;Read PortB<7:4> into W<3:0>
        andlw	0x0F

        movwf   keyPressed
;Pressed * --> Prev Go Back
        movlw   b'00001100'
        subwf   keyPressed, W
        bz      goToMenuScnSB

        goto SystemTime
goToMenuScnSB
        goto MenuScnSB

;==============================================================================================================
;Stage 3, After Inspection Menu A (Aim)
;Users choose what to see
;==============================================================================================================

AftInsMenuA ;Updates Display
        call    ClrLCD
        TABLEREAD AIM1
        call Switch_Lines
        TABLEREAD AIM2

AimWaitA
        GETINPUT AftInsMenuA

;~~~Paging~~~~~~
;Pressed #
        ;movwf   keyPressed
        movlw   b'00001110'
        subwf   keyPressed, W    
        bz      GoToAimB
;Pressed *
        movlw   b'00001100'
        subwf   keyPressed, W
        bz      GoToAimB
;~~~~~~~~~~~~~~~~~~~~
;Pressed 1
        movlw   b'00000000'
        subwf   keyPressed, W
        bz      FaultyList
;Pressed 2
        movlw   b'00000001'
        subwf   keyPressed, W
        bz      GoToTotalLights


        goto    AimWaitA
GoToAimB ;bz doesn't not have enough range to extend to menuscnsa
        goto    AftInsMenuB;AftInsMenuB
GoToTotalLights
        goto    TotalLights

;==============================================================================================================
;Stage 3.a, After Inspection Menu B (Aim)
;Users choose what to see
;==============================================================================================================
AftInsMenuB ;Updates Display
        call    ClrLCD
        TABLEREAD AIM3
        call Switch_Lines
        TABLEREAD AIM4

AimWaitB
        GETINPUT AftInsMenuB
        ;movwf   keyPressed
;~~~Paging~~~~~~
;Pressed #
        movlw   b'00001110'
        subwf   keyPressed, W
        bz      GoToAimA
;Pressed *
        movlw   b'00001100'
        subwf   keyPressed, W
        bz      GoToAimA
;~~~~~~~~~~~~~~~~~~~~
;Pressed 3
        movlw   b'00000010'
        subwf   keyPressed, W
        bz      GoToOpTime
;Pressed 4
        movlw   b'00000100'
        subwf   keyPressed, W
        bz      GoToOther

        goto    AimWaitB
GoToAimA ;bz doesn't not have enough range to extend to menuscnsa
        goto    AftInsMenuA;
GoToOther
        goto    Other
GoToOpTime
        goto   OpTime
;==============================================================================================================
;Stage 3.1, Faulty List
;Users choose what to see
;==============================================================================================================

FaultyList ;Updates Display
        
;===========LEDS 1 AND 2===================================================
FLOneTwo
        call    ClrLCD
        movlw   d'69' ;Check if the value i 1, 0 or AA. If the first 2, then the light is present and can be classified, otherwise the light is not present and should not be outputted
        subwf   EEADR, F ;Move to the part of the log where the light information is stored
        call    DispHeadLightA
        movlw   d'53'
        addwf   EEADR, F ;Move this to EEADR Pointer to the end
        goto    FLWait1
;===========================================================================

FLWait1
        GETINPUT FLWait1
        ;movwf   keyPressed
;Pressed *
        movlw   b'00001100'
        subwf   keyPressed, W
        bz      FLSevenBack
;Pressed #
        movlw   b'00001110'
        subwf   keyPressed, W     ;User entered 1, proceed with 1
        bz      FLThreeFour
;Pressed 0
        movlw   b'00001101'
        subwf   keyPressed, W
        bz      gotoAftInsMenuA

        goto    FLWait1
gotoAftInsMenuA
        goto AftInsMenuA

;===========LEDS 3 AND 4===================================================
FLThreeFour
        call    ClrLCD
        movlw   d'51' ;Check if the value i 1, 0 or AA. If the first 2, then the light is present and can be classified, otherwise the light is not present and should not be outputted
        subwf   EEADR, F ;Move to the part of the log where the light information is stored
        call    DispHeadLightA
        movlw   d'35'
        addwf   EEADR, F ;Move this to EEADR Pointer to the end
        goto    FLWait2
;===========================================================================

FLWait2
        GETINPUT FLWait2
        ;movwf   keyPressed
;Pressed *
        movlw   b'00001100'
        subwf   keyPressed, W
        bz      FLOneTwo
;Pressed #
        movlw   b'00001110'
        subwf   keyPressed, W     ;User entered 1, proceed with 1
        bz      FLFiveSix
;Pressed 0
        movlw   b'00001101'
        subwf   keyPressed, W
        bz      goAftInsMenuA

        goto    FLWait2
goAftInsMenuA
        goto    AftInsMenuA


;===========LEDS 5 AND 6===================================================
FLFiveSix
        call    ClrLCD
        movlw   d'33' ;Check if the value i 1, 0 or AA. If the first 2, then the light is present and can be classified, otherwise the light is not present and should not be outputted
        subwf   EEADR, F ;Move to the part of the log where the light information is stored
        call    DispHeadLightA
        movlw   d'17'
        addwf   EEADR, F ;Move this to EEADR Pointer to the end
        goto    FLWait3
;===========================================================================
FLWait3
        GETINPUT FLWait3
        ;movwf   keyPressed
;Pressed *
        movlw   b'00001100'
        subwf   keyPressed, W
        bz      FLThreeFour
;Pressed #
        movlw   b'00001110'
        subwf   keyPressed, W     ;User entered 1, proceed with 1
        bz      FLSevenBack
;Pressed 0
        movlw   b'00001101'
        subwf   keyPressed, W
        bz      gotAftInsMenuA

        goto    FLWait3
gotAftInsMenuA
        goto AftInsMenuA

;===========LEDS 7 AND EXIT===================================================
FLSevenBack
        call    ClrLCD
        movlw   d'15' ;Check if the value i 1, 0 or AA. If the first 2, then the light is present and can be classified, otherwise the light is not present and should not be outputted
        subwf   EEADR, F ;Move to the part of the log where the light information is stored
        call    DispHeadLightA
        movlw   d'1'
        subwf   EEADR, F ;Move this to EEADR Pointer to the end
        call    Switch_Lines
        TABLEREAD   LineOfBlanks
        goto    FLWait4
;===========================================================================
FLWait4
        GETINPUT FLWait4
        ;movwf   keyPressed
;Pressed *
        movlw   b'00001100'
        subwf   keyPressed, W
        bz      FLFiveSix
;Pressed #
        movlw   b'00001110'
        subwf   keyPressed, W     ;User entered 1, proceed with 1
        bz      gotoFLOneTwo
;Pressed 0
        movlw   b'00001101'
        subwf   keyPressed, W
        bz      toAftInsMenuA

        goto    FLWait4

toAftInsMenuA
        goto AftInsMenuA

gotoFLOneTwo
        goto    FLOneTwo


;Pressed any key from 1-0, A to D
;1-7 will have proper items, 8to 0, A to D display error messages

goBackAIMA ;bz doesn't not have enough range to extend to menuscnsa
        goto    AftInsMenuA

;==============================================================================================================
;Stage 3.2, Total Number of Headlights
;Users choose what to see
;==============================================================================================================
TotalLights ;Updates Display
        call    ClrLCD
        TABLEREAD NumLights

        ;Retrieve the total number of lights, which is 6 entries from the end of the log
        movlw   d'6'
        subwf   EEADR, F
        call    Read_EEPROM ;The data is in W
        addlw   0x30
        call    WrtLCD

        movlw   d'6'
        addwf   EEADR, F ;Point back to the end of the log

TLWait
        GETINPUT TotalLights

        
        ;movwf   keyPressed

;Pressed *
        movlw   b'00001100'
        subwf   keyPressed, W
        bz      goBackAIMA

        goto    TLWait

;==============================================================================================================
;Stage 3.3, Op Time
;Users choose what to see
;==============================================================================================================
OpTime ;Updates Display

        call    ClrLCD
        TABLEREAD OperationTime
        call Switch_Lines
        
     
        movf    tens, W
        call    WrtLCD
        movf    ones, W
        call    WrtLCD
        TABLEREAD Seconds

OTWait
        GETINPUT OpTime
        ;movwf   keyPressed

;Pressed *
        movlw   b'00001100'
        subwf   keyPressed, W
        bz      goBackAIMB

        goto    OTWait
goBackAIMB ;bz doesn't not have enough range to extend to menuscnsa
        goto    AftInsMenuB

;==============================================================================================================
;Stage 3.4, Other?
;Users choose what to see
;==============================================================================================================
Other ;Updates Display
    call    ClrLCD
    TABLEREAD OtherExport
    call Switch_Lines
    TABLEREAD OtherNewTest

OtherWait
    GETINPUT Other
    ;movwf   keyPressed
;~~~Paging~~~~~~
;Pressed *
    movlw   b'00001100'
    subwf   keyPressed, W
    bz      GoToAimB2

;Pressed 1
    movlw   b'00000000'
    subwf   keyPressed, W
    bz      GoToExportData
;Pressed 2
    movlw   b'00000001'
    subwf   keyPressed, W
    bz      GoToNewTest

    goto    OtherWait

GoToExportData ;bz doesn't not have enough range to extend to menuscnsa
    goto   ExportData
GoToNewTest
    goto   NewTest
GoToAimB2
    goto   AftInsMenuB
;==============================================================================================================
;Stage 3.4.2 , Starting a new test
;Users start the next test for the next set of lights
;==============================================================================================================

NewTest
    movlw   b'00010000'
    movwf   dutyCycle
    call ClrLCD
         TABLEREAD StartAnew
    call Switch_Lines
         TABLEREAD PressAnyKey
NewTestLoop
    btfss	PORTB,1   ;Wait until data is available from the keypad
    goto    NewTestLoop
    btfsc	PORTB,1
    goto    $-2
    call    putResultsToProm
    
    goto    MenuScnSA
;==============================================================================================================
;Stage 3.4.1, PC INTERFACING
;Users export the data into hyperterminal
;==============================================================================================================
ExportData
    call ExportDataToPC
    goto Other
    

;==============================================================================================================
;%%%%%%%%%%%SUBROUTINES%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
;==============================================================================================================

;******Hex Converter***************
KPHexToChar
          addwf     PCL,f ;By adding f to PCL, you get a 1 bit that corresponds to the character in your dt. So 0100000.. would be 2 in the dt
          dt        "123A456B789C*0#D"
;******Initialzing LCD****************
InitLCD

	;bsf PORTD,E     ;E default high --------------  Don't know what this is for

	;wait for the LCD
	call lcdLongDelay
	call lcdLongDelay
	call lcdLongDelay

	;Ensure 8-bit mode first (no way to immediately guarantee 4-bit mode)
	; -> Send b'0011' 3 times
    bcf     PORTD,RS       ;Instruction mode
	movlw   B'00110000' ;Instruction for 8 bit function set
	call    MovMSB
	call    ClkLCD         ;Finish last 4-bit send (if reset occurred in middle of a send)
	call    ClkLCD         ;Assuming 4-bit mode, set 8-bit mode
	call    lcdLongDelay   ;->max instruction time ~= 5ms
	call    ClkLCD         ;(note: if it's in 8-bit mode already, it will stay in 8-bit mode)

    ;set 4-bit mode.
	movlw B'00100000'
	call MovMSB
	call ClkLCD
	call    lcdLongDelay   ;->max instruction time ~= 5ms
	;Give LCD init instructions
	WRT_LCD B'00101000' ; 4 bits, 2 lines,5X8 dot
	call    lcdLongDelay   ;->max instruction time ~= 5ms
	WRT_LCD B'00001100' ; display on,cursor,blink
	call    lcdLongDelay   ;->max instruction time ~= 5ms
	WRT_LCD B'00000110' ; Increment,no shift
	call    lcdLongDelay   ;->max instruction time ~= 5ms
	;Ready to display characters
	call    ClrLCD
    bsf     PORTD,RS    ;Character mode

	return


;MovMSB: Move MSB of W to PORTD, without disturbing LSB
MovMSB
    andlw 0xF0
    iorwf PORTD,f
    iorlw 0x0F
    andwf PORTD,f
    return
;*************LCD Functions*****************
WrtLCD
	movwf   lcd_temp ; store original value
	call    MovMSB  ; move MSB to PORTD
	call    ClkLCD


	swapf   lcd_temp,w ; Swap LSB of value into MSB of W
    call    MovMSB    ; move to PORTD
    call    ClkLCD

    return

    ;ClrLCD: Clear the LCD display
ClrLCD
    bcf     PORTD,RS       ;Instruction mode
    WRT_LCD b'00000001'
    call    lcdLongDelay
    DISP_MODE_LCD ;Data mode, LCD displays data sent
    return

    ;ClkLCD: Pulse the E line low
ClkLCD ;Turns E up and down to write to the LCD
    ;LCD_DELAY
    bsf PORTD,E
    nop
	;LCD_DELAY   ; __    __
    bcf PORTD,E ;    |__|
	LCD_DELAY
    return

SftLft ;Shifts display left, clears and shifts again like a banner
    ;Also polls for the keypad entry to avoid using interrupts. Cleaner version will use interrupts
    ;Send command 0001 1000 to LCD repeatedly, with delays in between, to rotate the banner
    bcf     PORTD,RS       ;Instruction mode
    WRT_LCD b'00011000'
    DELAY
    DISP_MODE_LCD ;Data mode, LCD displays data sent
    return

Switch_Lines 
    bcf     PORTD, RS
    WRT_LCD b'11000000'
    bsf     PORTD, RS
    return

;*************Timers****************************************

lcdLongDelay
    movlw d'80'
    movwf lcd_d2
LLD_LOOP
    LCD_DELAY
    decfsz lcd_d2,f
    goto LLD_LOOP
    return

halfSecondDelay ;The working register can only hold 7 bits, this cannot hold a number big enough for the PIC to count to to slow down the banner movement.
    ;halfsecA used to contain maximum number
    ;halfsecB used to loop the counting up to halfsecA a certain number of times
    movlw b'00000111'
    movwf halfsecA
    movlw b'00000111'
    movwf halfsecB
    movlw b'10000000'
    movwf halfsecC


halfSecondDelayS
    decfsz halfsecA, f
    goto   $-2
    decfsz halfsecB, f
    goto $-2
    decfsz halfsecC, f

    goto halfSecondDelayS
    nop
    nop
    return

rotTimeDelay
    movlw b'0011111'
    movwf halfsecA
    movlw b'0011111'
    movwf halfsecB
    movlw b'0010111'
    movwf halfsecC

rotTimeDelayS
    decfsz halfsecA, f
    goto   $-2
    decfsz halfsecB, f
    goto $-2
    decfsz halfsecC, f

    goto halfSecondDelayS
    nop
    nop
    return

OperationDelay ;The working register can only hold 7 bits, this cannot hold a number big enough for the PIC to count to to slow down the banner movement.
    ;halfsecA used to contain maximum number
    ;halfsecB used to loop the counting up to halfsecA a certain number of times
    movlw b'00011111'
    movwf halfsecA
    movlw b'00011111'
    movwf halfsecB
    movlw b'00001100'
    movwf halfsecC


OperationDelayS
    decfsz halfsecA, f
    goto   $-2
    decfsz halfsecB, f
    goto $-2
    decfsz halfsecC, f

    goto OperationDelayS
    nop
    nop
    return

;******************RTC***********************
show_RTC
		;Move the cursor to the beginning
        bcf     PORTD,RS       ;Instruction mode
        ;Set Address Command
        WRT_LCD b'10000000' ; 4 bits, 2 lines,5X8 dot
        call    lcdLongDelay   ;->max instruction time ~= 5ms
        bsf     PORTD,RS    ;Character mode

        ;Get year
        DISP_MODE_LCD
		movlw	"2"				;First line shows 20**/**/**
		call	WrtLCD
		movlw	"0"
		call	WrtLCD
		rtc_read	0x06		;Read Address 0x06 from DS1307---year
		movf	tens_digit,W
		call	WrtLCD
		movf	ones_digit,W
		call	WrtLCD

		movlw	"/"
		call	WrtLCD

		;Get month
		rtc_read	0x05		;Read Address 0x05 from DS1307---month
		movf	tens_digit,W
		call	WrtLCD
		movf	ones_digit,W
		call	WrtLCD

		movlw	"/"
		call	WrtLCD

		;Get day
		rtc_read	0x04		;Read Address 0x04 from DS1307---day
		movf	tens_digit,W
		call	WrtLCD
		movf	ones_digit,W
		call	WrtLCD

        INST_MODE_LCD
		movlw	B'11000000'		;Next line displays (hour):(min):(sec) **:**:**
		call	WrtLCD
        DISP_MODE_LCD

		;Get hour
		rtc_read	0x02		;Read Address 0x02 from DS1307---hour
		movf	tens_digit,W
		call	WrtLCD
		movf	ones_digit,W
		call	WrtLCD
		movlw			":"
		call	WrtLCD

		;Get minute
		rtc_read	0x01		;Read Address 0x01 from DS1307---min
		movf	tens_digit,W
		call	WrtLCD
		movf	ones_digit,W
		call	WrtLCD
		movlw			":"
		call	WrtLCD

		;Get seconds
		rtc_read	0x00		;Read Address 0x00 from DS1307---seconds
		movf	tens_digit,W
		call	WrtLCD
		movf	ones_digit,W
		call	WrtLCD

		OPDELAY			;Delay for exactly one seconds and read DS1307 again
		return

i2c_common_setup
;input: none
;output: none
;desc: sets up I2C as master device with 100kHz baud rate

    movlw b'10000000'
    movwf SSPSTAT ;set I2C line leves, clear all flags.

    movlw 24 ;100kHz baud rate: 10000000 osc / [4*100000] -1
    movwf SSPADD ;RTC only supports 100kHz

    movlw b'00101000' ;Config SSP for Master Mode I2C
    movwf SSPCON1

    bsf SSPCON1,SSPEN ;Enable SSP module


    bcf PIR2, SSPIE ;don't cause an interrupt on SSPIF, please. We're just polling it.
    bcf PIR1, SSPIF
    bcf SSPSTAT, BF
    i2c_common_stop ;Ensure the bus is free
    return

;rtc Algorithms;;;;;;

write_rtc

    ;input: address of register in RTC
    ;output: none
    ;Desc: handles writing data to RTC
    ;Select the DS1307 on the bus, in WRITE mode
    i2c_common_start



    movlw 0xD0 ;DS1307 address | WRITE bit
    i2c_common_write
    i2c_common_check_ack WR_ERR1

    ;Write data to I2C bus (Register Address in RTC)
    movf regaddress,w ;Set register pointer in RTC
    i2c_common_write ;
    i2c_common_check_ack WR_ERR2

    ;Write data to I2C bus (Data to be placed in RTC register)
    movf databyte,w ;Write data to register in RTC
    i2c_common_write
    i2c_common_check_ack WR_ERR3

    goto WR_END

WR_ERR1
    nop
    movlw b'00001101'
    movwf LATA

    goto WR_END
WR_ERR2
    nop
    movlw b'00001111'
    movwf LATA
    bsf LATE,0
    goto WR_END
WR_ERR3
    nop
    movlw b'00001001'
    movwf LATA
    goto WR_END
WR_END
    i2c_common_stop ;Release the I2C bus
    return

;; ************************************************** READ RTC
read_rtc
;input: address of RTC
;output: DOUT or 0x75
;Desc: This reads from the selected address of the RTC
; and saves it into DOUT or address 0x75

;Select the DS1307 on the bus, in WRITE mode

    i2c_common_start

    movlw 0xD0 ;DS1307 address | WRITE bit
    i2c_common_write ;
    i2c_common_check_ack RD_ERR1

    ;Write data to I2C bus (Register Address in RTC)
    movf regaddress,w ;Set register pointer in RTC
    i2c_common_write ;
    i2c_common_check_ack RD_ERR2

    ;Re-Select the DS1307 on the bus, in READ mode
    i2c_common_repeatedstart
    movlw 0xD1 ;DS1307 address | READ bit
    i2c_common_write
    i2c_common_check_ack RD_ERR3

    ;Read data from I2C bus (Contents of Register in RTC)
    i2c_common_read
    movwf datachar
    i2c_common_nack ;Send acknowledgement of data reception


    goto RD_END

    RD_ERR1
    nop
    movlw b'00000011'
    movwf LATA
    goto RD_END
    RD_ERR2
    nop
    movlw b'00000101'
    movwf LATA
    goto RD_END
    RD_ERR3
    nop
    movlw b'00000111'
    movwf LATA
    goto RD_END
    ;Release the I2C bus
    RD_END
    i2c_common_stop
    return

rtc_convert
    ;input: W
    ;output: tens_digit, ones_digit
    ;desc: This subroutine converts the binary number
    ; in W into a two digit ASCII number and place
    ; each digit into the corresponding registers
    ; dig10 or dig1

    movwf convert_buffer ; B1 = HHHH LLLL
    swapf convert_buffer,w ; W = LLLL HHHH
    andlw 0x0f ; Mask upper four bits 0000 HHHH
    addlw 0x30 ; convert to ASCII
    movwf tens_digit ;saves into 10ths digit

    movf convert_buffer,w
    andlw 0x0f ; w = 0000 LLLL
    addlw 0x30 ; convert to ASCII
    movwf ones_digit ; saves into 1s digit
    return

;;====================================EEPROM==================================
ClearEEPROM
    clrf	EEADRH		;set EEPROM address to 0
    clrf	EEADR
    clrf	EEDATA
    call	Write_EEPROM
    return

InitEEPROM
;sets up the EEPROM for handling the operation logs
    clrf	EEADRH		;set EEPROM address to 0
    clrf	EEADR
    call	Read_EEPROM	;read value of first address
    movwf	EEADR		;set address of EEPROM to last log entry
    return

Read_EEPROM
    bcf			EECON1,EEPGD
    bcf			EECON1,CFGS
    bsf			EECON1,RD
    btfsc		EECON1,RD		;wait for read to finish
    bra			$-2
    movf		EEDATA,W
    return

Write_EEPROM
    ;writes EEDATA to current address in EEPROM
    bcf			EECON1,EEPGD	;point to DATA memory
    bcf			EECON1,CFGS		;access EEPROM
    bsf			EECON1,WREN		;enable writes

;mandatory writing sequence
    movlw		0x55			;writing sequence
    movwf		EECON2
    movlw		0xAA
    movwf		EECON2
    bsf			EECON1,WR		;set WR bit to begin write

    btfsc		EECON1,WR		;wait for write to finish
    bra			$-2
    bcf			EECON1,WREN		;disables writes on write complete set
    return

;========Inputting Data========================================================

PutTimeIntoEEP
    rtc_read    0x02 ;Read the hour
    incf        EEADR ;The place to write the data
    movff       tens_digit, EEDATA
    call        Write_EEPROM
    incf        EEADR
    movff       ones_digit, EEDATA
    call        Write_EEPROM

    rtc_read	0x01 ;Read the minute
    incf        EEADR ;The place to write the data
    movff       tens_digit, EEDATA
    movff       EEDATA, timingTenMinE
    call        Write_EEPROM
    incf        EEADR
    movff       ones_digit, EEDATA
    movff       EEDATA, timingMinuteE
    call        Write_EEPROM

    rtc_read	0x00 ;Read the second
    incf        EEADR ;The place to write the data
    movff       tens_digit, EEDATA
    movff       EEDATA, timingTenSecE
    call        Write_EEPROM
    incf        EEADR
    movff       ones_digit, EEDATA
    movff       EEDATA, timingOneSecE
    call        Write_EEPROM
    return


CalcOpTime ;Easy mode, always assume time is less than 2 minutes. Differneces of the largest digit should not be more than 1
    clrf    WREG
    addwf   timingTenMin, W
    subwf   timingTenMinE, W
    

    ;btfsc   WREG, 0 ;Test for a 1 or 0, If 1, add 10 minutes to WREG
    call    multTen ;Get 10s of minutes
    
    addwf   timingMinuteE, W ;Places the ASCII Hex number into timing Minute
    movwf   timingTotal
    clrf    WREG
    addwf   timingMinute, W
    subwf   timingTotal, W

    ;btfsc   WREG, 0 ;Test for a 1 or 0, If 1, add 60 seconds to WREG
    call    multSixty ;Get 60s of seconds
    movwf   timingTotal


    clrf    WREG
    addwf   timingTenSec, W
    subwf   timingTenSecE, W
    call    multTen

    addwf   timingOneSecE, W

    addwf   timingTotal, F

    clrf    WREG
    addwf   timingOneSec, W
    subwf   timingTotal, F

    movff   timingTotal, BIN
    call BIN2BCD
    return

multTen
    mullw   0xA ;Multiply 10 with the result in W to get the 10s of minutes/seconds
    clrf    WREG
    addwf   PRODL, W ;Result should be in lower Product register (not expecting huge number)
    return

multSixty
    mullw   0x3C ;Multiply 60 with the result in W to get the 60s of minutes/seconds
    clrf    WREG
    addwf   PRODL,W
    return

;========Outputting Data=======================================================
UpdateLCDwEEP
    incf EEADR
    call Read_EEPROM ;The data is in W
    call WrtLCD
    return

LEDStatToProm

    movwf   lightStatus
    incf    EEADR ;The place to write the data
    movff   lightStatus, EEDATA
    call    Write_EEPROM
    return

SolenoidPulse
    bsf PORTB, 0
    OPDELAY2
    ;DELAY
    ;DELAY
    ;DELAY
    bcf PORTB, 0
    OPDELAY2
    ;OPDELAY2
    return

resetLightStatus
    movlw   b'00000000'
    movwf   lightStatus
    return

BlankLightLog
    movlw       0xAA
    movwf       lightStatus
    movff       lightStatus,EEDATA
    incf EEADR
    call        Write_EEPROM
    incf EEADR
    call        Write_EEPROM
    incf EEADR
    call        Write_EEPROM
    incf EEADR
    call        Write_EEPROM
    incf EEADR
    call        Write_EEPROM
    incf EEADR
    call        Write_EEPROM
    incf EEADR
    call        Write_EEPROM

    incf EEADR


    return

;===================DISPLAYING BROKEN LEDS SUBROUTINES===========================================
EEPLighttoLCD
        call    Read_EEPROM ;The data is in W
        addlw   0x30
        call    WrtLCD
        movlw   ':'
        call    WrtLCD
        movlw   ' '
        call    WrtLCD
        return



CategorizeLEDS ;This subroutine displays the broken LEDS
        movlw   d'2'
        movwf   dispLightCount ;Set the counter to 1

        incf    EEADR
        call    Read_EEPROM ;1st LED status is obtained
;_____________________________________________________________________________________
CheckIfDNE ;Sees if entry is AA. If it is AA, then it will skip this light
        movwf   possibleAA
        movlw   0xAA
        subwf   possibleAA, W
        bz      JumpForward
;_____________________________________________________________________________________
        ;If the LED is 1, it works and does not need to be outputted
        ;If the LED is 0, it does not work and needs to be outputted to the screen
        clrf    WREG
        addwf   possibleAA, W
        decfsz  WREG ;If WREG contains a 0, decrementing it cause it to be non sero
        call LEDisBroken

        incf    dispLightCount
        incf    EEADR
        call    Read_EEPROM
        decfsz  WREG ;If WREG contains a 0, decrementing it cause it to be non sero
        call LEDisBroken

        incf    dispLightCount
        incf    EEADR
        call    Read_EEPROM
        decfsz  WREG ;If WREG contains a 0, decrementing it cause it to be non sero
        call LEDisBroken

        incf    dispLightCount
        incf    EEADR
        call    Read_EEPROM
        decfsz  WREG ;If WREG contains a 0, decrementing it cause it to be non sero
        call LEDisBroken

        incf    dispLightCount
        incf    EEADR
        call    Read_EEPROM
        decfsz  WREG ;If WREG contains a 0, decrementing it cause it to be non sero
        call LEDisBroken

        incf    dispLightCount
        incf    EEADR
        call    Read_EEPROM
        decfsz  WREG ;If WREG contains a 0, decrementing it cause it to be non sero
        call LEDisBroken

        incf    dispLightCount
        incf    EEADR
        call    Read_EEPROM
        decfsz  WREG ;If WREG contains a 0, decrementing it cause it to be non sero
        call LEDisBroken
        bra     CategorizeLEDend

JumpForward
        TABLEREAD   DoesNotExist
        incf    EEADR
        incf    EEADR
        incf    EEADR
        incf    EEADR
        incf    EEADR
        incf    EEADR
CategorizeLEDend
        return

LEDisBroken
        clrf    W
        addwf   dispLightCount, W
        addlw   0x30
        call    WrtLCD
        movlw   ' '
        call    WrtLCD
        return

NextLightInEEP
        movlw   d'2'
        addwf   EEADR, F
        call    Switch_Lines
        return

DispHeadLightA        ;THIS IS A PAIRED SUBROUTINE
        call    EEPLighttoLCD
        call    CategorizeLEDS
        call    NextLightInEEP
DispHeadLightB
        call    EEPLighttoLCD
        call    CategorizeLEDS
        return

;;Servo PULSING
pulseTesters

        movlw	B'00110000'	;Set internal oscillator frequency to 8MHz
		movwf	OSCCON ;Might not need to change this!
		bsf		OSCTUNE, 6	;Enable PLL - oscillator speed = 32MHz
		bcf		INTCON,GIE	;disable global interrupt
		bcf		INTCON,PEIE
        movlw	B'01001111' ;configure PR2, contains the PWM Period of 20 ms 1000. 10 ms is 0011
		movwf	PR2
        movff   dutyCycle, CCPR2L ;configure CCPR2L, contains the eight most-significant-bits of the PWM duty cycle.
        movff   dutyCycleLSB, CCP2CON
		movlw	B'00000110'	;configure T2CON, set prescaler to 16 (110)
		movwf	T2CON ;PERHAPS CLEAR THIS AT THE BEGINNING?
        return

resetTray
        movlw   b'00010000'
        movwf   dutyCycle
        movlw   b'00001100'
        movwf   dutyCycleLSB
        call    pulseTesters ;Change the rotation
        return

;***************************************************************
; AD CONVERT ROUTINE; Outputs a digital value and puts it in W
;***************************************************************
AD_CONV		
     	movff   adconZeroConfig,ADCON0 ;Move the configuration bits to ADCON0
     	bsf		ADCON0,1	;start the conversion

WAIT	btfsc	ADCON0,1	;wait until the conversion is completed
     	bra		WAIT		;poll the GO bit in ADCON0
     	movf	ADRESH,W	;move the high 8-bit to W
     	return

lightADAnalysis
    btfss   STATUS, 4 ;Check the negative bit to see if 1. If 1, the avg > W, so light not working
    goto    PositiveDifference
    goto    BadLight

PositiveDifference  ;If result is positive
    cpfsgt  lightThreshold    ;If determined light threshold is larger than the difference in before and after, light is not working.
    goto    GoodLight
    goto    BadLight

GoodLight
    movlw   b'00000001'
    goto    Done

BadLight
    incf    badHeadLightFlag
    clrf    WREG
Done
    call    LEDStatToProm
    return

ResetEEPROM
    movlw   0x0
    movwf   EEDATA
    call    Write_EEPROM
    incf    EEADR
    return
;====================================================
;PC Interfacing
;====================================================
InitPCInterface
;______EXTREMELY IMPORTANT SEQUENCE KEY TO GETTING PC INTERFACE TO WORK______
;    movlw	B'01110000'	;Set internal oscillator frequency to 8MHz
;    movwf	OSCCON ;Might not need to change this!
;    bsf     OSCTUNE, 6 ;--> This screws with the lcd outputs
;---------------------------------------------------------------------------

    MOVLW	12	;Baud rate 9600, assuming 10MHz oscillator. Must be 12 for data to export properly*******
    MOVWF	SPBRG
    clrf	TXSTA	;8 bits data, no parity, 1 stop

    CLRF	RCSTA
    BSF		RCSTA,SPEN	;enable single receive
    BSF		RCSTA,CREN	;continuous
    BSF		TXSTA,TXEN	;enable tx
    return

ExportDataToPC
    movlw	B'01110000'	;Set internal oscillator frequency to 8MHz
    movwf	OSCCON !
    
    ;Output Year
    movlw	"2"				;First line shows 20**/**/**
    movwf	TXREG		;write to PC
    call	lcdLongDelay
    movlw	"0"
    movwf	TXREG		;write to PC
    call	lcdLongDelay
    rtc_read	0x06		;Read Address 0x06 from DS1307---year
    movf	tens_digit,W
    movwf	TXREG		;write to PC
    call	lcdLongDelay
    movf	ones_digit,W
    movwf	TXREG		;write to PC
    call	lcdLongDelay

    movlw	"/"
    movwf	TXREG		;write to PC
    call	lcdLongDelay

    ;Get month
    rtc_read	0x05		;Read Address 0x05 from DS1307---month
    movf	tens_digit,W
    movwf	TXREG		;write to PC
    call	lcdLongDelay

    movf	ones_digit,W
    movwf	TXREG		;write to PC
    call	lcdLongDelay

    movlw	"/"
    movwf	TXREG		;write to PC
    call	lcdLongDelay

    ;Get day
    rtc_read	0x04		;Read Address 0x04 from DS1307---day
    movf	tens_digit,W
    movwf	TXREG		;write to PC
    call	lcdLongDelay
    movf	ones_digit,W
    movwf	TXREG		;write to PC
    call	lcdLongDelay

    movlw	" "
    movwf	TXREG		;write to PC
    call	lcdLongDelay
    movlw	" "
    movwf	TXREG		;write to PC
    call	lcdLongDelay
;    Output Month
;    Output Day

    movlw   0xA
    movwf	TXREG		;write to PC
    call	lcdLongDelay
    movlw   0xD
    movwf   TXREG
    call	lcdLongDelay

;    Output Time H
    movlw   d'75' ;Watch Out how much you decrement by!
    subwf   EEADR,F

    call    Read_EEPROM
    movwf	TXREG		;write to PC
    call	lcdLongDelay
    incf    EEADR

    call    Read_EEPROM
    movwf	TXREG		;write to PC
    call	lcdLongDelay
    incf    EEADR

    movlw   ':'
    movwf	TXREG		;write to PC
    call	lcdLongDelay

    ;Output Time M
    call    Read_EEPROM
    movwf	TXREG		;write to PC
    call	lcdLongDelay
    incf    EEADR

    call    Read_EEPROM
    movwf	TXREG		;write to PC
    call	lcdLongDelay
    incf    EEADR

    movlw   ':'
    movwf	TXREG		;write to PC
    call	lcdLongDelay
    ;Output Time S
    call    Read_EEPROM
    movwf	TXREG		;write to PC
    call	lcdLongDelay
    incf    EEADR

    call    Read_EEPROM
    movwf	TXREG		;write to PC
    call	lcdLongDelay

    movlw   d'70'
    addwf   EEADR,F

    movlw   ' '
    movwf	TXREG		;write to PC
    call	lcdLongDelay
    movlw   ' '
    movwf	TXREG		;write to PC
    call	lcdLongDelay

    movlw   0xA
    movwf	TXREG		;write to PC
    call	lcdLongDelay
    movlw   0xD
    movwf   TXREG
    call	lcdLongDelay

    ;Output Op Time
    movff   tens, TXREG
    call	lcdLongDelay
    movff   ones, TXREG
    call    lcdLongDelay
    movlw   ' '
    movwf	TXREG		;write to PC
    movlw   's'
    movwf	TXREG		;write to PC
    call	lcdLongDelay
    movlw   'e'
    movwf	TXREG		;write to PC
    call	lcdLongDelay
    movlw   'c'
    movwf	TXREG		;write to PC
    call	lcdLongDelay
    movlw   'o'
    movwf	TXREG		;write to PC
    call	lcdLongDelay
    movlw   'n'
    movwf	TXREG		;write to PC
    call	lcdLongDelay
    movlw   'd'
    movwf	TXREG		;write to PC
    call	lcdLongDelay
    movlw   's'
    movwf	TXREG		;write to PC
    call	lcdLongDelay

    movlw   0xA
    movwf	TXREG		;write to PC
    call	lcdLongDelay
    movlw   0xD
    movwf   TXREG
    call	lcdLongDelay
    ;Output Pass    
    movlw   'P'
    movwf	TXREG		;write to PC
    call	lcdLongDelay
    movlw   ':'
    movwf	TXREG
    call	lcdLongDelay
    movlw   ' '
    movwf	TXREG
    call	lcdLongDelay

    clrf    WREG
    addwf   passedLights, W
    addlw   0x30
    movwf   TXREG
    call	lcdLongDelay

    movlw   ' '
    movwf	TXREG
    call	lcdLongDelay

    ;Output Fail
    movlw   'F'
    movwf	TXREG		;write to PC
    call	lcdLongDelay
    movlw   ':'
    movwf	TXREG
    call	lcdLongDelay
    movlw   ' '
    movwf	TXREG
    call	lcdLongDelay

    clrf    WREG
    addwf   failedLights, W
    addlw   0x30
    movwf   TXREG
    call	lcdLongDelay

    ;Output Total

;    movlw	0x39			;'/' in ASCII code
;    movwf	TXREG		;write to PC
;    call	lcdLongDelay
    ;Log Format: 2014/04/05 10:53:53 P: 5 F: 2 T:
    movlw   0xA
    movwf	TXREG		;write to PC
    call	lcdLongDelay
    movlw   0xD
    movwf   TXREG
    call	lcdLongDelay
    movlw   0xA
    movwf	TXREG		;write to PC
    call	lcdLongDelay
    movlw   0xD
    movwf   TXREG
    call	lcdLongDelay

    bcf     OSCTUNE, 6 ; Return to 8 Mhz, not 32 Mhz (which would screw with the LED screen)
    return


;TIMER Subroutine for PC Interfacing (May not be required)
S_WAIT	MOVLW	081H
		MOVWF	LPCNT

TDEL	MOVLW	0FFH
		MOVWF	TIMCNT

TIMLP	DECFSZ	TIMCNT,F
     	GOTO	TIMLP
		DECFSZ	LPCNT,F
		GOTO	TDEL
     	RETURN

TestPC
    movlw	0x30
    movwf	TXREG		;write byte to PC
    PCDelay
    movlw	0x31
    movwf	TXREG		;write byte to PC
    PCDelay
    movlw	0x32
    movwf	TXREG		;write byte to PC
    PCDelay
    movlw	0x33
    movwf	TXREG		;write byte to PC
    PCDelay
    movlw	0x34
    movwf	TXREG		;write byte to PC
    PCDelay
    movlw	0x35
    movwf	TXREG		;write byte to PC
    PCDelay
    movlw	0x36
    movwf	TXREG		;write byte to PC
    PCDelay
    movlw	0x37
    movwf	TXREG		;write byte to PC
    PCDelay
    movlw	0x38
    movwf	TXREG		;write byte to PC
    PCDelay
    movlw	0x39
    movwf	TXREG		;write byte to PC
    PCDelay
    bra		TestPC
    return

;Binary to Ascii Code
BIN2BCD ;Move any number to the variable

;---------------------

;in: BIN
;out huns. tens, ones

;uses ADD-3 algoerthm

    movlw 8
    movwf count
    clrf huns
    clrf tens
    clrf ones

BCDADD3

    movlw 5
    subwf huns, 0
    btfsc STATUS, C
    call ADD3HUNS

    movlw 5
    subwf tens, 0
    btfsc STATUS, C
    call ADD3TENS

    movlw 5
    subwf ones, 0
    btfsc STATUS, C
    call ADD3ONES

    decf count, 1
    bcf STATUS, C
    rlcf BIN, 1
    rlcf ones, 1
    btfsc ones,4 ;
    call CARRYONES
    rlcf tens, 1

    btfsc tens,4 ;
    call CARRYTENS
    rlcf huns,1
    bcf STATUS, C

    movf count, 0
    btfss STATUS, Z
    GOTO BCDADD3


    movf huns, 0 ; add ASCII Offset
    addlw h'30'
    movwf huns

    movf tens, 0 ; add ASCII Offset
    addlw h'30'
    movwf tens

    movf ones, 0 ; add ASCII Offset
    addlw h'30'
    movwf ones

    RETURN

ADD3HUNS

    movlw 3
    addwf huns,1

    RETURN

ADD3TENS

    movlw 3
    addwf tens,1

    RETURN

ADD3ONES

    movlw 3
    addwf ones,1

    RETURN

CARRYONES
    bcf ones, 4
    bsf STATUS, C
    RETURN

CARRYTENS
    bcf tens, 4
    bsf STATUS, C
    RETURN

;Permanent logs will be stored in 100 Onwards
;
putResultsToProm
    clrf    EEADR
    clrf    EEADRH
    incf    EEADRH
    call    goToEndOfProm ;goes to the last available space

    movff   timingTotal, EEDATA
    call    Write_EEPROM
    incf    EEADR
    movff   passedLights, EEDATA
    call    Write_EEPROM
    incf    EEADR
    movff   failedLights, EEDATA
    call    Write_EEPROM
    ;Note: The pointers are maintained where they are, so that they can be used for prev logs
    return

goToEndOfProm ;Coupled Subroutine
    call    Read_EEPROM
    sublw   0xFF
    bnz     gotoNextPromIndex ;If there's something, go to next
    ;If there isn't anything, stay here
    return
    
gotoNextPromIndex
    incf    EEADR
    bra     goToEndOfProm


OutputLog
    movlw   d'3'
    subwf   EEADR, F

;   Time Writing
    call    Read_EEPROM
    sublw   0xFF
    bz      OutputLogS
    call    Read_EEPROM
OutputLogS
    movwf   BIN

    call    BIN2BCD
    clrf    WREG
    addwf   tens, W
    call    WrtLCD
    clrf    WREG
    addwf   ones, W
    call    WrtLCD
    movlw   's'
    call    WrtLCD
    movlw   ' '
    call    WrtLCD
    

;   Write Pass
    
    movlw   'P'
    call    WrtLCD
    movlw   ':'
    call    WrtLCD

    incf    EEADR
    call    Read_EEPROM
    addlw   0x30

    call    WrtLCD
    movlw   ' '
    call    WrtLCD

;   Write Fail
    
    movlw   'F'
    call    WrtLCD
    movlw   ':'
    call    WrtLCD
    incf    EEADR

    call    Read_EEPROM
    addlw   0x30

    call    WrtLCD
    movlw   ' '
    call    WrtLCD
    return

end
